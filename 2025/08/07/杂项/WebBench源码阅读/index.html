<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WebBench源码阅读.md | Ya0rk の Blog</title><meta name="author" content="Ya0rk"><meta name="copyright" content="Ya0rk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。   [仓库地址](EZLippi/WebBench: Webbench是Radim Kolar在1997年写的一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户">
<meta property="og:type" content="article">
<meta property="og:title" content="WebBench源码阅读.md">
<meta property="og:url" content="http://example.com/2025/08/07/%E6%9D%82%E9%A1%B9/WebBench%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html">
<meta property="og:site_name" content="Ya0rk の Blog">
<meta property="og:description" content="Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。   [仓库地址](EZLippi/WebBench: Webbench是Radim Kolar在1997年写的一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cloud.png">
<meta property="article:published_time" content="2025-08-07T07:27:43.000Z">
<meta property="article:modified_time" content="2025-08-07T13:12:01.036Z">
<meta property="article:author" content="Ya0rk">
<meta property="article:tag" content="CPP">
<meta property="article:tag" content="C">
<meta property="article:tag" content="源码学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cloud.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/08/07/%E6%9D%82%E9%A1%B9/WebBench%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WebBench源码阅读.md',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-07 21:12:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ya0rk の Blog"><span class="site-name">Ya0rk の Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">WebBench源码阅读.md</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-07T07:27:43.000Z" title="发表于 2025-08-07 15:27:43">2025-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-07T13:12:01.036Z" title="更新于 2025-08-07 21:12:01">2025-08-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">源码学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="WebBench源码阅读.md"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。</span><br></pre></td></tr></tbody></table></figure>
<p>  [仓库地址](<a target="_blank" rel="noopener" href="https://github.com/EZLippi/WebBench">EZLippi/WebBench: Webbench是Radim Kolar在1997年写的一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。官网地址:http://home.tiscali.cz/~cz210552/webbench.html</a>)</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/img/my_post_img/Pasted%20image%2020250807211134.png"></p>
<h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><ol>
<li>首先使用<code>getopt_long</code>解析参数并初始化程序。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((opt=getopt_long(argc,argv,<span class="string">"912Vfrt:p:c:?h"</span>,long_options,&amp;options_index))!=EOF )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span>  <span class="number">0</span> : <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'f'</span>: force=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>: force_reload=<span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'9'</span>: http10=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>: http10=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>: http10=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>: <span class="built_in">printf</span>(PROGRAM_VERSION<span class="string">"\n"</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>: benchtime=atoi(optarg);<span class="keyword">break</span>;	     </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'p'</span>: </span><br><span class="line">            <span class="comment">/* proxy server parsing server:port */</span></span><br><span class="line">            tmp=<span class="built_in">strrchr</span>(optarg,<span class="string">':'</span>);</span><br><span class="line">            proxyhost=optarg;</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in option --proxy %s: Missing hostname.\n"</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(tmp==optarg+<span class="built_in">strlen</span>(optarg)<span class="number">-1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in option --proxy %s Port number is missing.\n"</span>,optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            *tmp=<span class="string">'\0'</span>;</span><br><span class="line">            proxyport=atoi(tmp+<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>: usage();<span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'c'</span>: clients=atoi(optarg);<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>optarg</code>:<br>   这个是<code>getopt</code>和<code>getopt_long</code>函数族中的全局变量，用于<strong>存储命令行选项的参数值</strong>。如果某个选项有参数值（如<code>-o output.txt</code>），那<code>optarg</code>会设置为指向<code>output.txt</code>字符串的指针。</p>
</blockquote>
<ol start="2">
<li>利用<code>optind</code>找到命令行参数中网站的url，然后调用<code>build_request</code>向对应网站发送请求</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(optind==argc) {</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"webbench: Missing URL!\n"</span>);</span><br><span class="line">	usage();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(clients==<span class="number">0</span>) clients=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(benchtime==<span class="number">0</span>) benchtime=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copyright */</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Webbench - Simple Web Benchmark "</span>PROGRAM_VERSION<span class="string">"\n"</span></span><br><span class="line">		<span class="string">"Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n"</span></span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">build_request(argv[optind]);</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p> <code>optind</code>:<br> <strong>下一个待处理参数的索引</strong>，默认从1开始，跳过args[0]程序名。</p>
</blockquote>
<blockquote>
<p>关于这里的<code>fprintf</code>为什么使用<code>stderr</code>输出：<br><code>stdout</code>通常用于<strong>程序的实际结果输出</strong>，这些内容可能是用户需要重定向到文件或管道的数据。<br><code>stderr</code>用于<strong>日志、错误、调试信息或非核心内容</strong>。即使&nbsp;<code>stdout</code>&nbsp;被重定向，<code>stderr</code>&nbsp;仍会直接显示在终端。</p>
</blockquote>
<h4 id="build-request"><a href="#build-request" class="headerlink" title="build_request"></a>build_request</h4><p>通过用户参数构造请求头。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bzero(host,MAXHOSTNAMELEN);</span></span><br><span class="line">    <span class="comment">//bzero(request,REQUEST_SIZE);</span></span><br><span class="line">    <span class="comment">// 清空地址内容</span></span><br><span class="line">    <span class="built_in">memset</span>(host,<span class="number">0</span>,MAXHOSTNAMELEN);</span><br><span class="line">    <span class="built_in">memset</span>(request,<span class="number">0</span>,REQUEST_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据请求方法设置http协议版本</span></span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span> &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_HEAD &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_OPTIONS &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(method==METHOD_TRACE &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拼接请求头中的请求方法</span></span><br><span class="line">    <span class="keyword">switch</span>(method)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> METHOD_GET: <span class="built_in">strcpy</span>(request,<span class="string">"GET"</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_HEAD: <span class="built_in">strcpy</span>(request,<span class="string">"HEAD"</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_OPTIONS: <span class="built_in">strcpy</span>(request,<span class="string">"OPTIONS"</span>);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> METHOD_TRACE: <span class="built_in">strcpy</span>(request,<span class="string">"TRACE"</span>);<span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个空格</span></span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一些验证</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==<span class="built_in">strstr</span>(url,<span class="string">"://"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n%s: is not a valid URL.\n"</span>,url);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(url)&gt;<span class="number">1500</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"URL is too long.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 验证是否以http:// 开头，不区分大小写</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>!=strncasecmp(<span class="string">"http://"</span>,url,<span class="number">7</span>)) </span><br><span class="line">    { </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nOnly HTTP protocol is directly supported, set --proxy for others.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* protocol/host delimiter */</span></span><br><span class="line">	<span class="comment">// 分离协议和主机地址</span></span><br><span class="line">    i=<span class="built_in">strstr</span>(url,<span class="string">"://"</span>)-url+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strchr</span>(url+i,<span class="string">'/'</span>)==<span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nInvalid URL syntax - hostname don't ends with '/'.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取代理主机地址</span></span><br><span class="line">	<span class="comment">// 如果代理主机地址为空，就需要从url获取</span></span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get port from hostname */</span></span><br><span class="line">        <span class="keyword">if</span>(index(url+i,<span class="string">':'</span>)!=<span class="literal">NULL</span> &amp;&amp; index(url+i,<span class="string">':'</span>)&lt;index(url+i,<span class="string">'/'</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strchr</span>(url+i,<span class="string">':'</span>)-url-i);</span><br><span class="line">            <span class="comment">//bzero(tmp,10);</span></span><br><span class="line">            <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strncpy</span>(tmp,index(url+i,<span class="string">':'</span>)+<span class="number">1</span>,<span class="built_in">strchr</span>(url+i,<span class="string">'/'</span>)-index(url+i,<span class="string">':'</span>)<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">/* printf("tmp=%s\n",tmp); */</span></span><br><span class="line">            proxyport=atoi(tmp);</span><br><span class="line">            <span class="keyword">if</span>(proxyport==<span class="number">0</span>) proxyport=<span class="number">80</span>;</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">	        <span class="comment">//strcspn 从字符串&nbsp;`url + i`&nbsp;的位置开始，查找第一个出现&nbsp;`/`&nbsp;字符的位置，</span></span><br><span class="line">		    <span class="comment">//并返回从起始位置到该字符的&nbsp;**长度（字节数）**</span></span><br><span class="line">            <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strcspn</span>(url+i,<span class="string">"/"</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// printf("Host=%s\n",host);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request+<span class="built_in">strlen</span>(request),url+i+<span class="built_in">strcspn</span>(url+i,<span class="string">"/"</span>));</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// printf("ProxyHost=%s\nProxyPort=%d\n",proxyhost,proxyport);</span></span><br><span class="line">        <span class="built_in">strcat</span>(request,url);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拼接协议类型</span></span><br><span class="line">    <span class="keyword">if</span>(http10==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">" HTTP/1.0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (http10==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">" HTTP/1.1"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">strcat</span>(request,<span class="string">"\r\n"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"User-Agent: WebBench "</span>PROGRAM_VERSION<span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span> &amp;&amp; http10&gt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"Host: "</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(request,host);</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"\r\n"</span>);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"Pragma: no-cache\r\n"</span>);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request,<span class="string">"Connection: close\r\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* add empty line at end */</span></span><br><span class="line">    <span class="keyword">if</span>(http10&gt;<span class="number">0</span>) <span class="built_in">strcat</span>(request,<span class="string">"\r\n"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nRequest:\n%s\n"</span>,request);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>strcspn(url + i, "/")</code>&nbsp;的功能解析:<br>这个函数调用用于&nbsp;<strong>从字符串&nbsp;<code>url + i</code>&nbsp;的位置开始，查找第一个出现&nbsp;<code>/</code>&nbsp;字符的位置</strong>，并返回从起始位置到该字符的&nbsp;<strong>长度（字节数）</strong>。</p>
</blockquote>
<p>最终效果大概如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">GET /test.jpg HTTP/1.1 </span><br><span class="line">User-Agent: WebBench 1.5 </span><br><span class="line">Host:192.168.10.1 </span><br><span class="line">Pragma: no-cache </span><br><span class="line">Connection: close </span><br><span class="line">\r\n(这里有一个空行，用\r\n表示)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="bench"><a href="#bench" class="headerlink" title="bench"></a>bench</h4><ol>
<li>该函数首先调用自己封装的接口<code>Socket</code>创建目标主机间的套接字并使用<code>connect</code>连接，测试是否成功，如果没有成功就退出程序；否则关闭连接。</li>
<li>使用<code>pipe()</code>创建pipe用于子进程和主进程之间通信。</li>
<li>创建子进程调用<code>benchcore</code>进行测试，将测试结果写入pipe，主进程读取结果。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bench</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i,j,k;	</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">0</span>;    <span class="comment">// 进程id</span></span><br><span class="line">    FILE *f;        <span class="comment">// 文件符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否能够目标服务器建立连接。注意：只是检测，并不是开始压测工作</span></span><br><span class="line">    i=Socket(proxyhost==<span class="literal">NULL</span>?host:proxyhost,proxyport);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) { </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nConnect to server failed. Aborting benchmark.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    close(i);<span class="comment">//检测完毕，关闭连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(mypipe))</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"pipe failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;clients;i++)</span><br><span class="line">    {</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="comment">// fork error,剩下的子进程不创建了</span></span><br><span class="line">        <span class="keyword">if</span>(pid &lt;= (<span class="type">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">/* make childs faster */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环创建子进程过程中，只要有一个创建失败，跳出该函数</span></span><br><span class="line">    <span class="keyword">if</span>( pid &lt; (<span class="type">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"problems forking worker no. %d\n"</span>,i);</span><br><span class="line">        perror(<span class="string">"fork failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是子进程的执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(pid == (<span class="type">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 执行压测程序</span></span><br><span class="line">        <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">            benchcore(host,proxyport,request);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            benchcore(proxyhost,proxyport,request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把压测结果写到管道的写端</span></span><br><span class="line">        f=fdopen(mypipe[<span class="number">1</span>],<span class="string">"w"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            perror(<span class="string">"open pipe for writing failed."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 写入结果</span></span><br><span class="line">        <span class="built_in">fprintf</span>(f,<span class="string">"%d %d %d\n"</span>,speed,failed,bytes);</span><br><span class="line">        fclose(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 这是父进程的执行逻辑</span></span><br><span class="line">        <span class="comment">// 打开管道的读端</span></span><br><span class="line">        f=fdopen(mypipe[<span class="number">0</span>],<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>) </span><br><span class="line">        {</span><br><span class="line">            perror(<span class="string">"open pipe for reading failed."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</span></span><br><span class="line">        setvbuf(f,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给与结果相关的变量置0</span></span><br><span class="line">        speed=<span class="number">0</span>;</span><br><span class="line">        failed=<span class="number">0</span>;</span><br><span class="line">        bytes=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//  从流 stream 读取格式化输入。</span></span><br><span class="line">            pid=<span class="built_in">fscanf</span>(f,<span class="string">"%d %d %d"</span>,&amp;i,&amp;j,&amp;k);</span><br><span class="line">            <span class="keyword">if</span>(pid&lt;<span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Some of our childrens died.\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            speed+=i;</span><br><span class="line">            failed+=j;</span><br><span class="line">            bytes+=k;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(--clients==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//把所有子进程的压测结果读取完毕后，跳出循环</span></span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        fclose(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印压测结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n"</span>,</span><br><span class="line">            (<span class="type">int</span>)((speed+failed)/(benchtime/<span class="number">60.0f</span>)),</span><br><span class="line">            (<span class="type">int</span>)(bytes/(<span class="type">float</span>)benchtime),</span><br><span class="line">            speed,</span><br><span class="line">            failed);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<blockquote>
<p> <strong><code>fdopen()</code></strong>:<br> <code>FILE *fdopen(int fd, const char *mode);</code> 将&nbsp;<strong>已有的文件描述符</strong>&nbsp;包装成&nbsp;<strong>标准文件流</strong>，从而允许使用&nbsp;<code>fgets</code>、<code>fread</code>&nbsp;等高级函数</p>
</blockquote>
<h4 id="benchcore"><a href="#benchcore" class="headerlink" title="benchcore"></a>benchcore</h4><ol>
<li>自定义超时信号处理函数，如果超时就设置<code>timerexpired = 1</code>；用<code>alarm()</code>设置超时时间，如果超时就会发送<code>SIGALRM</code>信号</li>
<li>进行压力测试。如果没有超时，就一直访问这个网页。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">const</span> <span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span> *req)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> rlen;               <span class="comment">// 数据长度</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>];         <span class="comment">// 缓冲区，保存数据</span></span><br><span class="line">    <span class="type">int</span> s,i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span>    <span class="comment">// 注册信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup alarm signal handler */</span></span><br><span class="line">    sa.sa_handler=alarm_handler;    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    sa.sa_flags=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="keyword">if</span>(sigaction(SIGALRM,&amp;sa,<span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过 benchtime 秒后，产生一个 SIGALRM 信号</span></span><br><span class="line">    alarm(benchtime); <span class="comment">// after benchtime,then exit</span></span><br><span class="line"></span><br><span class="line">    rlen=<span class="built_in">strlen</span>(req);</span><br><span class="line">    nexttry:<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 定时器到，退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(timerexpired)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(failed&gt;<span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                failed--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与目标服务器建立连接</span></span><br><span class="line">        s=Socket(host,port);   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接失败，则失败数量 failed++</span></span><br><span class="line">        <span class="keyword">if</span>(s&lt;<span class="number">0</span>) </span><br><span class="line">        { </span><br><span class="line">            failed++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// write 会返回的实际字节数，如果不能把请求消息完全发送，那也是失败了</span></span><br><span class="line">        <span class="keyword">if</span>(rlen!=write(s,req,rlen)) </span><br><span class="line">        {</span><br><span class="line">            failed++;</span><br><span class="line">            close(s);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (http10 == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 关闭连接s的写端,即不在发送数据，但还能接收数据的意思，没有错误发送则返回 0</span></span><br><span class="line">            <span class="keyword">if</span> (shutdown(s, <span class="number">1</span>)) { </span><br><span class="line">                failed++; </span><br><span class="line">                close(s); </span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要等待结果返回</span></span><br><span class="line">        <span class="keyword">if</span>(force==<span class="number">0</span>) </span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* read all available data from socket */</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 定时器到，退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(timerexpired) </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="comment">// 从连接 s 中每次读取1500字节数据到 buf，返回实际读取的字节数</span></span><br><span class="line">                i=read(s,buf,<span class="number">1500</span>);</span><br><span class="line">                <span class="comment">// i &lt; 0,表示有错误发生</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) </span><br><span class="line">                { </span><br><span class="line">                    failed++;</span><br><span class="line">                    close(s);</span><br><span class="line">                    <span class="keyword">goto</span> nexttry;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">break</span>;      <span class="comment">// i为0，表示数据已经读取完毕</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        bytes += i; <span class="comment">// 加上读取的字节数</span></span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭套接字失败</span></span><br><span class="line">        <span class="keyword">if</span>(close(s)) {</span><br><span class="line">            failed++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        speed++;<span class="comment">// 成功访问，成功数量 speed++</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h4><p>函数原型：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;getopt.h&gt; // 必须包含此头文件</span><br><span class="line"></span><br><span class="line">int getopt_long(</span><br><span class="line">    int argc,                         // main() 的 argc（参数计数）</span><br><span class="line">    char *const argv[],        // main() 的 argv（参数数组）</span><br><span class="line">    const char *optstring,   // 短选项字符串（如 "ho:v"）</span><br><span class="line">    const struct option *longopts, // 长选项结构体数组</span><br><span class="line">    int *longindex                           // 返回长选项的索引（可设为 NULL）</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p><code>getopt_long</code>是一个用于命令行解析的C语言库函数，它是对<code>getopt</code>的扩展，支持长选项和短选项。</p>
<p>该函数有以下解析功能：</p>
<ul>
<li><p><strong>短选项</strong><br>单字符选项，通常以&nbsp;<code>-</code>&nbsp;开头，例如&nbsp;<code>-h</code>、<code>-v</code>。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">./program -h -v</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>长选项</strong><br>多字符选项，以&nbsp;<code>--</code>&nbsp;开头，例如&nbsp;<code>--help</code>、<code>--version</code>。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">./program --<span class="built_in">help</span> --version</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>带参数的选项</strong><br>选项可以接受参数，例如&nbsp;<code>--output=file.txt</code>&nbsp;或&nbsp;<code>-o file.txt</code>。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">./program -o output.txt</span><br><span class="line">./program --output=output.txt</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Ya0rk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/08/07/%E6%9D%82%E9%A1%B9/WebBench%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">http://example.com/2025/08/07/%E6%9D%82%E9%A1%B9/WebBench%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Ya0rk の Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPP/">CPP</a><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">源码学习</a></div><div class="post_share"><div class="social-share" data-image="/img/cloud.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/07/%E6%9D%82%E9%A1%B9/CPP%E5%9F%BA%E7%A1%80/" title="CPP基础.md"><img class="cover" src="/img/avatar.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CPP基础.md</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/14/OS/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/" title="任务管理器"><img class="cover" src="/img/longlin.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">任务管理器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/08/07/%E6%9D%82%E9%A1%B9/CPP%E5%9F%BA%E7%A1%80/" title="CPP基础.md"><img class="cover" src="/img/avatar.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-07</div><div class="title">CPP基础.md</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Ya0rk</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ya0rk/Ya0rk.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="toc-number">2.</span> <span class="toc-text">代码细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#main"><span class="toc-number">2.1.</span> <span class="toc-text">main</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#build-request"><span class="toc-number">2.2.</span> <span class="toc-text">build_request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bench"><span class="toc-number">2.3.</span> <span class="toc-text">bench</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#benchcore"><span class="toc-number">2.4.</span> <span class="toc-text">benchcore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getopt-long"><span class="toc-number">3.1.</span> <span class="toc-text">getopt_long</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2025 By Ya0rk</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>